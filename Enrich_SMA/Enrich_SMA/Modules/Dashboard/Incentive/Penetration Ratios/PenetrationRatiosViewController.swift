//
//  PenetrationRatiosViewController.swift
//  Enrich_SMA
//
//  Created by Harshal on 21/01/22.
//  Copyright (c) 2022 e-zest. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol PenetrationRatiosDisplayLogic: class
{
  func displaySomething(viewModel: PenetrationRatios.Something.ViewModel)
}

class PenetrationRatiosViewController: UIViewController, PenetrationRatiosDisplayLogic
{
    var interactor: PenetrationRatiosBusinessLogic?
    
    // MARK: Object lifecycle
    
    @IBOutlet private weak var tableView: UITableView!
    @IBOutlet private weak var bottomFilterView: BottomFilterView!
    
    var headerModel: EarningsHeaderDataModel?
    var headerGraphData: GraphDataEntry?
    
    var dataModel = [EarningsCellDataModel]()
    var graphData = [GraphDataEntry]()
    
    var dateSelectedTitle : String = ""
    
    var fromFilters : Bool = false
    
    var fromChartFilter : Bool = false
    
    var dateRangeType : DateRangeType = .mtd
    var penetrationCutomeDateRange:DateRange = DateRange(Date.today.lastYear(), Date.today)
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = PenetrationRatiosInteractor()
        let presenter = PenetrationRatiosPresenter()
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        bottomFilterView.delegate = self
        bottomFilterView.setup(.basic)
        doSomething()
        tableView.register(UINib(nibName: CellIdentifier.earningDetailsHeaderCell, bundle: nil), forCellReuseIdentifier: CellIdentifier.earningDetailsHeaderCell)
        tableView.register(UINib(nibName: CellIdentifier.earningDetailsThreeValueCell, bundle: nil), forCellReuseIdentifier: CellIdentifier.earningDetailsThreeValueCell)
        
        fromChartFilter = false
        dateRangeType = .mtd
        headerModel?.value = Double("")
        updatePenetrationData(startDate: Date.today.startOfMonth)
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.navigationController?.navigationBar.isHidden = false
        self.navigationController?.addCustomBackButton(title: "Back")
    }
    
    // MARK: Do something
    
    //@IBOutlet weak var nameTextField: UITextField!
    
    func updatePenetrationData(startDate: Date?, endDate: Date = Date().startOfDay) {
        
        EZLoadingActivity.show("Loading...", disableUI: true)
//        DispatchQueue.main.async { [unowned self] () in
            penetrationRatioData(startDate:  startDate ?? Date.today, endDate: endDate)
//            tableView.reloadData()
//            EZLoadingActivity.hide()
//        }
    }
    
    func updatePenetrationData(atIndex indexPath:IndexPath, withStartDate startDate: Date?, endDate: Date = Date().startOfDay, rangeType:DateRangeType) {
        let selectedIndex = indexPath.row - 1
        let dateRange = DateRange(startDate!, endDate)
        
        //Date filter applied
        let dateFilteredPenetration = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (resourceUtilization) -> Bool in
            if let date = resourceUtilization.date?.date()?.startOfDay {
                return date >= dateRange.start && date <= dateRange.end
            }
            return false
        })
        
        if(selectedIndex >= 0){
            let model = dataModel[selectedIndex]
            model.dateRangeType = rangeType
            if model.dateRangeType == .cutome {
                model.customeDateRange = dateRange
            }
            
            print("date range \(dateRange)")
            update(modeData: model, withData: dateFilteredPenetration, atIndex: selectedIndex, dateRange: dateRange, dateRangeType: rangeType)
            
            graphData[selectedIndex] = getGraphEntry(model.title, atIndex: selectedIndex, dateRange: dateRange, dateRangeType: rangeType)
        }
        
        tableView.reloadRows(at: [indexPath], with: .automatic)
    }
    
    func getGraphEntry(_ title:String, forData data:[Dashboard.GetRevenueDashboard.Revenue_transaction]? = nil, atIndex index : Int, dateRange:DateRange, dateRangeType: DateRangeType) -> GraphDataEntry
    {
        let units = xAxisUnits(forDateRange: dateRange, rangeType: dateRangeType)
        let values = graphData(forData: data, atIndex: index, dateRange: dateRange, dateRangeType: dateRangeType, title: title)
        let graphColor = EarningDetails.PenetrationRatios.graphBarColor
        
        return GraphDataEntry(graphType: .barGraph, dataTitle: title, units: units, values: values, barColor: graphColor.first!)
    }
    
    func graphData(forData data:[Dashboard.GetRevenueDashboard.Revenue_transaction]? = nil, atIndex index : Int, dateRange:DateRange, dateRangeType: DateRangeType, title: String) -> [Double] {
        
        var filteredPenetrationRatio = data
        
        if data == nil, (data?.count ?? 0 <= 0) {
            
            
            filteredPenetrationRatio = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (penetrationRatio) -> Bool in
                if let date = penetrationRatio.date?.date()?.startOfDay {
                    
                    return date >= dateRange.start && date <= dateRange.end
                }
                return false
            })
        }
        let uniqueInvoices = filteredPenetrationRatio?.compactMap({$0.invoice_number}).unique(map: {$0}) ?? []
        
        //Service count per Invoice
        if(index == 0){
            return calculateServiceCountPerInvoice(filterArray: filteredPenetrationRatio ?? [], invoiceNumbers: uniqueInvoices, dateRange: dateRange, dateRangeType: dateRangeType)
        }
        else if(index == 1){ // product to service
            return calculateProductToService(filterArray: filteredPenetrationRatio ?? [], invoiceNumbers: uniqueInvoices, dateRange: dateRange, dateRangeType: dateRangeType)
        }
        else if(index == 2){ // App Booking
            
            //customers served
            let filteredCustomerEngagement = GlobalVariables.technicianDataJSON?.data?.salon_feedbacks?.filter({ (customerEngagement) -> Bool in
                if let date = customerEngagement.date?.date()?.startOfDay {
                    
                    return date >= dateRange.start && date <= dateRange.end
                }
                return false
            })
            
            return calculateAppBooking(filterArray: filteredPenetrationRatio ?? [], customerServedArray: filteredCustomerEngagement ?? [], invoiceNumbers: uniqueInvoices, dateRange: dateRange, dateRangeType: dateRangeType)
        }
        else if(index == 3) {// cross sell
          
            
            let crossSell = GlobalVariables.technicianDataJSON?.data?.cross_sell_transactions?.filter({ (crossSell) -> Bool in
                if let date = crossSell.date?.date()?.startOfDay {
                    
                    return date >= dateRange.start && date <= dateRange.end
                }
                return false
            })
            
            return calculateCrossSell(filterArray: crossSell ?? [], dateRange: dateRange, dateRangeType: dateRangeType)
            
        }
        else {
            let penerationRatioFromFilters = GlobalVariables.technicianDataJSON?.data?.filters?.penetration_ratios
            return calculatePenetrationRatioForDyanmicData(penetrationRatioFromServer: penerationRatioFromFilters ?? [], filteredPenetrationRatio: filteredPenetrationRatio ?? [], dateRange: dateRange, dateRangeType: dateRangeType, title: title)
        }
    }
    
    
    func calculateServiceCountPerInvoice(filterArray: [Dashboard.GetRevenueDashboard.Revenue_transaction], invoiceNumbers : [String], dateRange: DateRange, dateRangeType: DateRangeType) -> [Double]{
        var values = [Double]()
        //service count per invoice
        let serviceCount = filterArray.filter({($0.product_category_type ?? "").isEmpty == false})
        
        var serviceRatio : Double = 0.0
        switch dateRangeType
        {
        case .yesterday, .today, .week, .mtd:
            let dates = dateRange.end.dayDates(from: dateRange.start)
            for objDt in dates {
                let data = serviceCount.filter({$0.date == objDt})
                let uniqueInvoice = data.compactMap({$0.invoice_number}).unique(map: {$0})
                    let count = uniqueInvoice.count
                
                if(data.count > 0){
                    
                    serviceRatio =  Double(data.count) / Double(count)
                    values.append(serviceRatio)
                }
                else {
                    values.append(0.0)
                }
            }
        case .qtd, .ytd:
//            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//            for qMonth in months {
//                let value = serviceCount.map ({ (services) -> Double in
//                    if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                       rMonth == qMonth
//                    {
//                        serviceRatio =  Double((Double(1.0)) / Double(invoiceNumbers.count))
//                        return serviceRatio
//                    }
//                    return 0.0
//                }).reduce(0) {$0 + $1}
//
//                values.append(value)
//            }
        
            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
            for month in months {
                let service = serviceCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                
                let uniqueInvoice = service.compactMap({$0.invoice_number}).unique(map: {$0})
                    let count = uniqueInvoice.count
                
                if(service.count > 0){
                    
                    serviceRatio =  Double(service.count) / Double(count)
                    values.append(serviceRatio)
                }
                else {
                    values.append(0.0)
                }
            }
            
            
        case .cutome:
            
            if dateRange.end.days(from: dateRange.start) > 31
            {
//                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//                for qMonth in months {
//                    let value = serviceCount.map ({ (services) -> Double in
//                        if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                           rMonth == qMonth
//                        {
//                            serviceRatio =  Double((Double(1.0)) / Double(invoiceNumbers.count))
//                            return serviceRatio
//                        }
//                        return 0.0
//                    }).reduce(0) {$0 + $1}
//
//                    values.append(value)
//                }
                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
                for month in months {
                    let service = serviceCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                    
                    let uniqueInvoice = service.compactMap({$0.invoice_number}).unique(map: {$0})
                        let count = uniqueInvoice.count
                    
                    if(service.count > 0){
                        
                        serviceRatio =  Double(service.count) / Double(count)
                        values.append(serviceRatio)
                    }
                    else {
                        values.append(0.0)
                    }
                }
            }
            else {
                let dates = dateRange.end.dayDates(from: dateRange.start)
                for objDt in dates {
                    let data = serviceCount.filter({$0.date == objDt})
                    let uniqueInvoice = data.compactMap({$0.invoice_number}).unique(map: {$0})
                        let count = uniqueInvoice.count
                    print("service \(data.count) invoice \(count)")
                    if(data.count > 0){
                        
                        serviceRatio =  Double(data.count) / Double(count)
                        values.append(serviceRatio)
                    }
                    else {
                        values.append(0.0)
                    }
                }
            }
        }
        return values
    }
    
    func calculateProductToService(filterArray: [Dashboard.GetRevenueDashboard.Revenue_transaction], invoiceNumbers : [String], dateRange: DateRange, dateRangeType: DateRangeType) -> [Double]{
        var values = [Double]()
        
        //service count per invoice
        let serviceCount = filterArray.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        
        //product to service
        let productCount = filterArray.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.retail)})
        
        var productRatio :Double = 0.0
        
        switch dateRangeType
        {
        case .yesterday, .today, .week, .mtd:
            let dates = dateRange.end.dayDates(from: dateRange.start)
            for objDt in dates {
                let data = productCount.filter({$0.date == objDt})
                let serviceData = serviceCount.filter({$0.date == objDt})
                
                if(data.count > 0){
                productRatio =  Double(data.count) / Double(serviceData.count)
                    values.append(productRatio)
                }
                else {
                    values.append(0.0)
                }

            }
        case .qtd, .ytd:
//            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//            for qMonth in months {
//                let value = productCount.map ({ (services) -> Double in
//                    if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                       rMonth == qMonth
//                    {
//                        productRatio =  Double((Double(1.0)) / Double(serviceCount.count))
//                        return Double(productRatio)
//                    }
//                    return 0.0
//                }).reduce(0) {$0 + $1}
//
//                values.append(value)
//            }
            
            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
            for month in months {
                let product = productCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                let service = serviceCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                
                
                if(service.count > 0){
                    
                    productRatio =  Double(product.count) / Double(service.count)
                    values.append(productRatio)
                }
                else {
                    values.append(0.0)
                }
            }
        case .cutome:
            
            if dateRange.end.days(from: dateRange.start) > 31
            {
//                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//                for qMonth in months {
//                    let value = productCount.map ({ (services) -> Double in
//                        if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                           rMonth == qMonth
//                        {
//                            productRatio =  Double((Double(1.0)) / Double(serviceCount.count))
//                            return Double(productRatio)
//                        }
//                        return 0.0
//                    }).reduce(0) {$0 + $1}
//
//                    values.append(value)
//                }
                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
                for month in months {
                    let product = productCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                    let service = serviceCount.filter({($0.date?.contains(month)) ?? false}).map({$0})
                    
                    
                    if(service.count > 0){
                        
                        productRatio =  Double(product.count) / Double(service.count)
                        values.append(productRatio)
                    }
                    else {
                        values.append(0.0)
                    }
                }
            }
            else {
                let dates = dateRange.end.dayDates(from: dateRange.start)
                for objDt in dates {
                    let data = productCount.filter({$0.date == objDt})
                    let serviceData = serviceCount.filter({$0.date == objDt})
                    
                    if(data.count > 0){
                    productRatio =  Double(data.count) / Double(serviceData.count)
                        values.append(productRatio)
                    }
                    else {
                        values.append(0.0)
                    }
                }
            }
        }
        
        return values
    }
    
    func calculateAppBooking(filterArray: [Dashboard.GetRevenueDashboard.Revenue_transaction], customerServedArray: [Dashboard.GetRevenueDashboard.Salon_feedbacks] ,invoiceNumbers : [String], dateRange: DateRange, dateRangeType: DateRangeType) -> [Double]{
        var values = [Double]()
        
        //app booking
        let appBooking = filterArray.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services) && (($0.platform ?? "").containsIgnoringCase(find:platform.CMA))})
        
        var appBookingRatio : Double = 0.0
        if(invoiceNumbers.count > 0) {
            appBookingRatio =  Double(appBooking.count / invoiceNumbers.count)
        }
        
        //customers served - those are customer_id which are served
        let filterCustomerServed = filterArray.unique(map: {$0.customer_id})
        var customersServedCount : Double = 0.0
        for objCustomersServed in filterCustomerServed {
            customersServedCount += 1
        }
        
        switch dateRangeType
        {
        case .yesterday, .today, .week, .mtd:
            let dates = dateRange.end.dayDates(from: dateRange.start)
            for objDt in dates {

                let appointment = appBooking.filter({$0.date == objDt})
                let customer = filterCustomerServed.filter({$0.date == objDt})
                if(appointment.count > 0 || customer.count > 0){
                    values.append(Double(appointment.count) / Double(customer.count))
                }
                else {
                    values.append(0.0)
                }
            }
        case .qtd, .ytd:
            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
            for month in months {
                let appbooking = appBooking.filter({($0.date?.contains(month)) ?? false}).map({$0.paid_service_revenue})
                let appbookingvalue = appbooking.reduce(0) {$0 + ($1 ?? 0.0)}
                
        
                //customers served - those are customer_id which are served
                let customer = filterArray.unique(map: {$0.customer_id})
                let customergvalue = filterCustomerServed.count //customer.reduce(0) {$0 + $1}
                if(appbookingvalue > 0 || customergvalue > 0){
                let value = Double(appbookingvalue) / Double(customergvalue)
                values.append(value)
                }
                else {
                    values.append(0.0)
                }
            }
        case .cutome:
            
            if dateRange.end.days(from: dateRange.start) > 31
            {
                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "yyyy-MM")
                for month in months {
                    let appbooking = appBooking.filter({($0.date?.contains(month)) ?? false}).map({$0.paid_service_revenue})
                    let appbookingvalue = appbooking.reduce(0) {$0 + ($1 ?? 0.0)}
                    
            
                    let customer = filterCustomerServed.unique(map: {$0.customer_id})
                    let customergvalue = customer.count //reduce(0) {$0 + ($1 ?? Int(0.0))}
                    if(appbookingvalue > 0 || customergvalue > 0){
                    let value = Double(appbookingvalue) / Double(customergvalue)
                    values.append(value)
                    }
                    else {
                        values.append(0.0)
                    }
                }
                
            }
            else {
                let dates = dateRange.end.dayDates(from: dateRange.start)
                for objDt in dates {
                    let appointment = appBooking.filter({$0.date == objDt})
                    let customer = filterCustomerServed.filter({$0.date == objDt})
                    if(appointment.count > 0 || customer.count > 0){
                        values.append(Double(appointment.count) / Double(customer.count))
                    }
                    else {
                        values.append(0.0)
                    }
                }
            }
        }
        
        return values
    }
    
    
    func calculateCrossSell(filterArray: [Dashboard.GetRevenueDashboard.Cross_sell_transactions], dateRange: DateRange, dateRangeType: DateRangeType) -> [Double]{
        
        var values = [Double]()
        switch dateRangeType
        {
        case .yesterday, .today, .week, .mtd:
            let dates = dateRange.end.dayDates(from: dateRange.start)
            for objDt in dates {
                if let data = filterArray.filter({$0.date == objDt}).first{
                    values.append(Double(data.paid_service_revenue ?? 0))
                }
                else {
                    values.append(Double(0.0))
                }
            }
        case .qtd, .ytd:
            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
            for qMonth in months {
                let value = filterArray.map ({ (services) -> Double in
                    if let rMonth = services.date?.date()?.string(format: "MMM yy"),
                       rMonth == qMonth
                    {
                        return (Double(services.paid_service_revenue ?? 0))
                    }
                    return 0.0
                }).reduce(0) {$0 + $1}
                
                values.append(value)
            }
            
        case .cutome:
            
            if dateRange.end.days(from: dateRange.start) > 31
            {
                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
                for qMonth in months {
                    let value = filterArray.map ({ (services) -> Double in
                        if let rMonth = services.date?.date()?.string(format: "MMM yy"),
                           rMonth == qMonth
                        {
                            return (Double(services.paid_service_revenue ?? 0))
                        }
                        return 0.0
                    }).reduce(0) {$0 + $1}
                    
                    values.append(value)
                }
            }
            else {
                let dates = dateRange.end.dayDates(from: dateRange.start)
                for objDt in dates {
                    if let data = filterArray.filter({$0.date == objDt}).first
                    {
                        values.append((Double(data.paid_service_revenue ?? 0)))
                    }
                    else {
                        values.append(Double(0.0))
                    }
                }
            }
            
        }
        return values
    }
    
    func calculateCompareValue(revenueTransaction: [Dashboard.GetRevenueDashboard.Revenue_transaction], comapreCategories : [String], serviceCount : Int) -> Int {
        var value = 0
        
       // let serviceCount = 10// revenueTransaction.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        
//        if(revenueTransaction.count > 0)
//        {
        /**
         for objTransaction in penetrationRatio  {
             for objPenetration in penetrationRatioFromServer {
                 if((objTransaction.category == objPenetration.compare_label!) || (objTransaction.category == objPenetration.to_compare_label!)) {
                     categotyCount = categotyCount + 1
                     filterPenetrationArrayWithCategoryData.append(objTransaction)
                 }
                 
                 if((objTransaction.sub_category == objPenetration.compare_label) || (objTransaction.sub_category == objPenetration.to_compare_label)){
                     subCategoryCount = subCategoryCount + 1
                     filterPenetrationArrayWithCategoryData.append(objTransaction)
                 }
             }
         }
         */
        
            for objComapreCat in comapreCategories{
                for objRevenueTrans in revenueTransaction{
                    if(objComapreCat.containsIgnoringCase(find: "All")){
                        value = serviceCount
                    }
                    else {
                        if((objRevenueTrans.product_category_type ?? "").containsIgnoringCase(find: CategoryTypes.services)) {
                            
                       if ((objRevenueTrans.category ?? "").containsIgnoringCase(find: objComapreCat) || (objRevenueTrans.sub_category ?? "").containsIgnoringCase(find: objComapreCat)){
                           // if((revenueTransaction.category?.equalsIgnoreCase(string: objComapreCat))! || ((revenueTransaction.sub_category?.equalsIgnoreCase(string: objComapreCat)) != nil))//{
                            value += 1
                            }
                        }
                    }
                }
            }
       // }
        return value
    }
    
    func calculateComparisonRatio(revenueTransaction : [Dashboard.GetRevenueDashboard.Revenue_transaction], comapreCategory : [String], toComapreCategory : [String], serviceCountData : Int) -> Double{
        var value = 0.0
        
        let compareValue = Double(calculateCompareValue(revenueTransaction: revenueTransaction, comapreCategories: toComapreCategory, serviceCount: serviceCountData))
        if(compareValue > 0){
            value = Double(Double(calculateCompareValue(revenueTransaction: revenueTransaction, comapreCategories: comapreCategory, serviceCount: serviceCountData)) / compareValue)
        }
        
        if(value.isNaN){
            return 0
        }
        return value
    }
    
    func calculatePenetrationRatioForDyanmicData(penetrationRatioFromServer: [Dashboard.GetRevenueDashboard.Penetration_ratios], filteredPenetrationRatio: [Dashboard.GetRevenueDashboard.Revenue_transaction] , dateRange: DateRange, dateRangeType: DateRangeType, title : String) -> [Double]{
        var values = [Double]()
        let serviceCountInt = filteredPenetrationRatio.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        var categotyCount : Int = 0
        var subCategoryCount : Int = 0
        var ratio : Double = 0.0
        var filterPenetrationArrayWithCategoryData = [Dashboard.GetRevenueDashboard.Revenue_transaction]()
        if(penetrationRatioFromServer.count > 0){
            for objTransaction in filteredPenetrationRatio  {
                for objPenetration in penetrationRatioFromServer {
                    if((objTransaction.category == objPenetration.compare_label!) || (objTransaction.category == objPenetration.to_compare_label!)) {
                        categotyCount = categotyCount + 1
                        filterPenetrationArrayWithCategoryData.append(objTransaction)
                    }
                    
                    if((objTransaction.sub_category == objPenetration.compare_label) || (objTransaction.sub_category == objPenetration.to_compare_label)){
                        subCategoryCount = subCategoryCount + 1
                        filterPenetrationArrayWithCategoryData.append(objTransaction)
                    }
                }
            }
        }
        var compareCategories = [String]()
        var toCompareCategories = [String]()
        let category = penetrationRatioFromServer.filter({($0.heading?.containsIgnoringCase(find: title))!})
        for objPenetration in category{
            if(objPenetration.heading == title){
                compareCategories.append(objPenetration.compare_label ?? "")
                toCompareCategories.append(objPenetration.to_compare_label ?? "")
            }
            
        switch dateRangeType
        {
        case .yesterday, .today, .week, .mtd:
            let dates = dateRange.end.dayDates(from: dateRange.start)
            for objDt in dates {
                if let data = filterPenetrationArrayWithCategoryData.filter({$0.date == objDt}).first {
                    
                    values.append(calculateComparisonRatio(revenueTransaction: filterPenetrationArrayWithCategoryData, comapreCategory: compareCategories, toComapreCategory: toCompareCategories, serviceCountData: serviceCountInt.count))
                    
//                    ratio = Double(subCategoryCount / categotyCount)
//                    values.append(ratio)
                }
                else {
                    values.append(Double(0.0))
                }
            }
        case .qtd, .ytd:
            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
            for qMonth in months {
                let value = filterPenetrationArrayWithCategoryData.map ({ (services) -> Double in
                    if let rMonth = services.date?.date()?.string(format: "MMM yy"),
                       rMonth == qMonth
                    {
                        if(categotyCount == 0){
                            ratio = 0
                        }
                        else {
                            ratio = Double(subCategoryCount / categotyCount)
                        }
                        return ratio
                    }
                    return 0.0
                }).reduce(0) {$0 + $1}
                
                values.append(value)
            }
            
        case .cutome:
            
            if dateRange.end.days(from: dateRange.start) > 31
            {
                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
                for qMonth in months {
                    let value = filterPenetrationArrayWithCategoryData.map ({ (services) -> Double in
                        if let rMonth = services.date?.date()?.string(format: "MMM yy"),
                           rMonth == qMonth
                        {
                            if(categotyCount == 0){
                                ratio = 0
                            }
                            else {
                                ratio = Double(subCategoryCount / categotyCount)
                            }
                            return (ratio)
                        }
                        return 0.0
                    }).reduce(0) {$0 + $1}
                    
                    values.append(value)
                }
            }
            else {
                let dates = dateRange.end.dayDates(from: dateRange.start)
                for objDt in dates {
                    if let data = filterPenetrationArrayWithCategoryData.filter({$0.date == objDt}).first
                    {
                        if(categotyCount == 0){
                            ratio = 0
                        }
                        else {
                            ratio = Double(subCategoryCount / categotyCount)
                        }
                    }
                    else {
                        values.append(Double(0.0))
                    }
                }
            }
        }
        
        }
        return values
    }
    
//    func calculatePenetrationRatioForDyanmicData(penetrationRatioFromServer: [Dashboard.GetRevenueDashboard.Penetration_ratios], filteredPenetrationRatio: [Dashboard.GetRevenueDashboard.Revenue_transaction] , dateRange: DateRange, dateRangeType: DateRangeType, title : String) -> [Double]{
//        var values = [Double]()
//
//        var categotyCount : Int = 0
//        let subCategoryCount : Int = 0
//        var ratio : Double = 0.0
//        let filterPenetrationArrayWithCategoryData = [Dashboard.GetRevenueDashboard.Revenue_transaction]()
//
////        //service count
////        let filteredPenetrationRatio = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (penetrationRatio) -> Bool in
////            if let date = penetrationRatio.date?.date()?.startOfDay {
////
////                return date >= dateRange.start && date <= dateRange.end
////            }
////            return false
////        }) ?? []
//
//        let serviceCountInt = filteredPenetrationRatio.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
//        var compareCategories = [String]()
//        var toCompareCategories = [String]()
//
//
//
//        switch dateRangeType
//        {
//        case .yesterday, .today, .week, .mtd:
//            let dates = dateRange.end.dayDates(from: dateRange.start)
//
//            for objDt in dates {
//                if let data = filteredPenetrationRatio.filter({$0.date == objDt}).first {
//
//
//
//                    let dateValues = calculateCategoryData(data: filteredPenetrationRatio, comapreCategory: compareCategories, toCompareCategory: toCompareCategories, dateRange: dateRange, dateRangeType: dateRangeType, titleData: title)
//                    let arr1 = dateValues[0].category
//                    let arr2 = dateValues[0].subCategory
//                    if(arr1.count > 0){
//                    ratio = Double(arr2.count / arr1.count)
//                    }
//                    else {
//                        ratio = 0
//                    }
//                    values.append(ratio)
//                    let category = penetrationRatioFromServer.filter({($0.heading?.containsIgnoringCase(find: title))!})
//
//
//                    for objPenetration in category{
//                        if(objPenetration.heading == title){
//                        compareCategories.append(objPenetration.compare_label ?? "")
//                        toCompareCategories.append(objPenetration.to_compare_label ?? "")
//                        }
//                    }
//                    values.append(calculateComparisonRatio(revenueTransaction: data, comapreCategory: compareCategories, toComapreCategory: toCompareCategories, serviceCountData: serviceCountInt.count))
//                    print("######## Title \(title)")
//                    print("Compare category \(compareCategories) \n ************ To compare category \(toCompareCategories)")
//                    compareCategories.removeAll()
//                    toCompareCategories.removeAll()
//                }
//                else {
//                    values.append(Double(0.0))
//                }
//            }
//
//        case .qtd, .ytd:
//            let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//            for qMonth in months {
//                let value = filterPenetrationArrayWithCategoryData.map ({ (services) -> Double in
//                    if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                       rMonth == qMonth
//                    {
//                        if(categotyCount == 0){
//                            ratio = 0
//                        }
//                        else {
//                            ratio = Double(subCategoryCount / categotyCount)
//                        }
//                        return ratio
//                    }
//                    return 0.0
//                }).reduce(0) {$0 + $1}
//
//                values.append(value)
//            }
//
//        case .cutome:
//
//            if dateRange.end.days(from: dateRange.start) > 31
//            {
//                let months = dateRange.end.monthNames(from: dateRange.start, withFormat: "MMM yy")
//                for qMonth in months {
//                    let value = filterPenetrationArrayWithCategoryData.map ({ (services) -> Double in
//                        if let rMonth = services.date?.date()?.string(format: "MMM yy"),
//                           rMonth == qMonth
//                        {
//                            if(categotyCount == 0){
//                                ratio = 0
//                            }
//                            else {
//                                ratio = Double(subCategoryCount / categotyCount)
//                            }
//                            return (ratio)
//                        }
//                        return 0.0
//                    }).reduce(0) {$0 + $1}
//
//                    values.append(value)
//                }
//            }
//            else {
//                let dates = dateRange.end.dayDates(from: dateRange.start)
//                for objDt in dates {
//                    if let data = filterPenetrationArrayWithCategoryData.filter({$0.date == objDt}).first
//                    {
//                        if(categotyCount == 0){
//                            ratio = 0
//                        }
//                        else {
//                            ratio = Double(subCategoryCount / categotyCount)
//                        }
//                    }
//                    else {
//                        values.append(Double(0.0))
//                    }
//                }
//            }
//        }
//        return values
//
//    }
    
    func calculateCategoryData(data : [Dashboard.GetRevenueDashboard.Revenue_transaction] ,comapreCategory : [String], toCompareCategory : [String] , dateRange: DateRange, dateRangeType: DateRangeType, titleData: String) -> [(category : [Dashboard.GetRevenueDashboard.Revenue_transaction], subCategory: [Dashboard.GetRevenueDashboard.Revenue_transaction])]{
        
//        var categotyCount : Int = 0
//        var subCategoryCount : Int = 0
        
        let penerationRatioFromFilters = GlobalVariables.technicianDataJSON?.data?.filters?.penetration_ratios ?? []
        
        var categoryArray = [Dashboard.GetRevenueDashboard.Revenue_transaction]()
        var subcategoryData = [Dashboard.GetRevenueDashboard.Revenue_transaction]()
//        //service count
//        let filteredPenetrationRatio = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (penetrationRatio) -> Bool in
//            if let date = penetrationRatio.date?.date()?.startOfDay {
//
//                return date >= dateRange.start && date <= dateRange.end
//            }
//            return false
//        }) ?? []
//        let serviceCount = dataFromRevenueTransaction.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        print("TITLE ############# \(titleData)")
//        if(data.count > 0){
//            for objPenetration in data {
//
//                for objTemp in penerationRatioFromFilters {
//                for objComapreCategory in comapreCategory{
//                    for objToCompareCategory in toCompareCategory{
//                        if(((objPenetration.category == objComapreCategory ) || (objPenetration.sub_category == objToCompareCategory || objTemp.compare_label == objComapreCategory || objTemp.to_compare_label == objToCompareCategory)) && objPenetration.category != nil && objPenetration.sub_category != nil){
//                    categotyCount += 1
//                categoryArray.append(objPenetration)
//                        }
//                    if(objPenetration.sub_category?.contains("All") == true){
//                        subcategoryData.append(objPenetration)
//                        //subCategoryCount = serviceCount.count
//                    }
//                    else {
//                        if(((objPenetration.sub_category == objToCompareCategory ) || (objPenetration.category == objComapreCategory || objTemp.compare_label == objComapreCategory || objTemp.to_compare_label == objToCompareCategory) ) && objPenetration.category != nil && objPenetration.sub_category != nil){
//                        subCategoryCount += 1
//                        subcategoryData.append(objPenetration)
//                        }
//                    }
//                }
//            }
//                }
//            }
//        }
        
        for objData in data{
            for objPenetration in penerationRatioFromFilters{
            print("Category ********** \(objData.category) \nSubCategory ########## \(objData.sub_category)")
                if(comapreCategory.contains(objData.category ?? "") || comapreCategory.contains(objPenetration.compare_label ?? "")){
                categoryArray.append(objData)
            }
                else if(toCompareCategory.contains(objData.sub_category ?? "") || toCompareCategory.contains(objPenetration.to_compare_label ?? "")){
                subcategoryData.append(objData)
            }
            }
        }
        
        return [(category : categoryArray, subCategory : subcategoryData)]
    }
    func doSomething()
    {
        let request = PenetrationRatios.Something.Request()
        interactor?.doSomething(request: request)
    }
    
    func displaySomething(viewModel: PenetrationRatios.Something.ViewModel)
    {
        //nameTextField.text = viewModel.name
    }
    
    func penetrationRatioData(startDate : Date, endDate : Date = Date().startOfDay) {
        
        dataModel.removeAll()
        graphData.removeAll()
        
        let filteredPenetrationRatio = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (penetrationRatio) -> Bool in
            if let date = penetrationRatio.date?.date()?.startOfDay {
                
                return date >= startDate && date <= endDate
            }
            return false
        }) ?? []
        
        //Handle Graph Scenarios
        let dateRange = DateRange(startDate, endDate)
        var graphRangeType = dateRangeType
        var graphDateRange = dateRange
        let filteredPenetrationForGraph = filteredPenetrationRatio
        if (dateRangeType == .yesterday || dateRangeType == .today) {
           // filteredPenetrationForGraph = nil
            graphRangeType = .mtd
            graphDateRange = DateRange(graphRangeType.date!, Date().startOfDay)
        }
        
        
        //invoice data
        let invoiceNumber = filteredPenetrationRatio.filter({($0.invoice_number ?? "") != ""})
        //let updateUniqueData = invoiceNumber?.unique(map: {$0.invoice_number})
        
        //service count per invoice
        let serviceCount = filteredPenetrationRatio.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        let invoiceService = filteredPenetrationRatio.compactMap({$0.invoice_number}).unique(map: {$0})
        var serviceRatio : Double = 0.0
        if(invoiceService.count > 0){
            serviceRatio =  Double(serviceCount.count) / Double(invoiceService.count)
        }
        
        //"Service Count Per Invoice"
        //Data Model
        let serviceCountPerInvoiceModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Service Count Per Invoice", value: [String(serviceCount.count ),String(invoiceService.count ),serviceRatio.roundedStringValue(toFractionDigits: 2)], subTitle: ["Services", "Invoice", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
        dataModel.append(serviceCountPerInvoiceModel)
        //Graph Data
        graphData.append(getGraphEntry(serviceCountPerInvoiceModel.title, forData: filteredPenetrationForGraph, atIndex: 0, dateRange: graphDateRange, dateRangeType: graphRangeType))
        
        
        //product to service
        let productCount = filteredPenetrationRatio.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.retail)})
        
        var productRatio :Double = 0.0
        if(serviceCount.count > 0){
            productRatio = Double(productCount.count) / Double(serviceCount.count)
        }
        
        //"Product To Service"
        //Data Model
        let productToServiceModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Product To Service", value: [String(productCount.count ),String(serviceCount.count ),productRatio.roundedStringValue(toFractionDigits: 2)], subTitle: ["Product", "Services", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
        dataModel.append(productToServiceModel)
        //Graph Data
        graphData.append(getGraphEntry(productToServiceModel.title, forData: filteredPenetrationForGraph, atIndex: 1, dateRange: graphDateRange, dateRangeType: graphRangeType))
        
        
        //app booking
        let appBooking = filteredPenetrationRatio.filter({(($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)) && (($0.platform ?? "").containsIgnoringCase(find:platform.CMA))})
        
        var appBookingRatio : Double = 0.0
        
        //customers served - those are customer_id which are served
        let filterCustomerServed = filteredPenetrationRatio.filter({(($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)) && $0.customer_id != nil && $0.customer_id != 0}).unique(map: {$0.customer_id})
        
        if(filterCustomerServed.count > 0) {
            appBookingRatio =  Double(appBooking.count) / Double(filterCustomerServed.count)
        }
        
        //"App Booking"
        //Data Model
        let appBookingModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "App Booking", value: [String(appBooking.count ),String(filterCustomerServed.count),appBookingRatio.roundedStringValue(toFractionDigits: 2)], subTitle: ["Appointments" ,"Total Served", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
        dataModel.append(appBookingModel)
        //Graph Data
        graphData.append(getGraphEntry(appBookingModel.title, forData: filteredPenetrationForGraph, atIndex: 2, dateRange: graphDateRange, dateRangeType: graphRangeType))
        
        
        //cross sell
       // let crossSell = GlobalVariables.technicianDataJSON?.data?.cross_sell_transactions
        
        let filteredCrossSell = GlobalVariables.technicianDataJSON?.data?.cross_sell_transactions?.filter({ (crossSell) -> Bool in
            if let date = crossSell.date?.date()?.startOfDay {
                
                return date >= startDate && date <= endDate
            }
            return false
        })
        
        if let crossSellData = filteredCrossSell, crossSellData.count > 0 {
            
            var crossSellRevenueCount : Double = 0.0
            for objCrossSell in crossSellData {
                crossSellRevenueCount += objCrossSell.paid_service_revenue ?? 0.0
            }
            
            //"Cross Sell"
            //Data Model
            let crossSellModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Cross Sell", value: [String(crossSellData.count), crossSellRevenueCount.roundedStringValue()], subTitle: ["Services", "Revenue"], showGraph: true, cellType: .DoubleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
            dataModel.append(crossSellModel)
            //Graph Data
            graphData.append(getGraphEntry(crossSellModel.title, forData: filteredPenetrationForGraph, atIndex: 3, dateRange: graphDateRange, dateRangeType: graphRangeType))
            
        }
        else {
            let crossSellModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Cross Sell", value: ["NA","NA"], subTitle: ["Services", "Revenue"], showGraph: true, cellType: .DoubleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
            dataModel.append(crossSellModel)
            //Graph Data
            graphData.append(getGraphEntry(crossSellModel.title, forData: filteredPenetrationForGraph, atIndex: 3, dateRange: graphDateRange, dateRangeType: graphRangeType))
        }
        
        
        let penerationRatioFromFilters = GlobalVariables.technicianDataJSON?.data?.filters?.penetration_ratios
        
        var categotyCount : Int = 0
        var subCategoryCount : Int = 0
        var ratio : Double = 0.0
        var index = 4 // to set the index for graphs
        if(penerationRatioFromFilters?.count ?? 0 > 0){
            for objPenetration in penerationRatioFromFilters! {
                
                for objTransaction in filteredPenetrationRatio {
                    
                    let filter = objPenetration.compare_categories?.filter({($0 == objTransaction.category ?? "") || ($0 == objTransaction.sub_category ?? "")})
                    categotyCount += filter?.count ?? 0
                    
                    if(objPenetration.to_compare_categories?.contains("All") == true){
                        subCategoryCount = serviceCount.count
                    }
                    else {
                    let catfilter = objPenetration.to_compare_categories?.filter({($0 == objTransaction.sub_category ?? "") || ($0 == objTransaction.category ?? "")})
                    subCategoryCount += catfilter?.count ?? 0
                    }
                    
                }
                if(subCategoryCount > 0){
                    ratio = Double(categotyCount) / Double(subCategoryCount)
                }
                
                //"penetrationModel"
                //Data Model
                let penetrationModel = EarningsCellDataModel(earningsType: .PenetrationRatios, title: objPenetration.heading ?? "", value: [String(categotyCount),String(subCategoryCount),ratio.roundedStringValue(toFractionDigits: 2)], subTitle: [objPenetration.compare_label ?? "" ,objPenetration.to_compare_label ?? "", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
                dataModel.append(penetrationModel)
                //Graph Data
                graphData.append(getGraphEntry(penetrationModel.title, forData: filteredPenetrationForGraph, atIndex: index, dateRange: graphDateRange, dateRangeType: graphRangeType))
                print("INDEX \(index)")
                print("------------------ penetration ratio title \(penetrationModel.title)")
                //                dataModel.append(EarningsCellDataModel(earningsType: .PenetrationRatios, title: objPenetration.heading ?? "", value: [String(subCategoryCount),String(categotyCount),String(ratio)], subTitle: [objPenetration.compare_label ?? "" ,objPenetration.to_compare_label ?? "", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: dateRangeType, customeDateRange: penetrationCutomeDateRange))
                
                categotyCount = 0
                subCategoryCount = 0
                ratio = 0.0
                index += 1
            }
        }
        
        headerModel =  EarningsHeaderDataModel(earningsType: .PenetrationRatios, value: 0.0, isExpanded: false, dateRangeType: graphRangeType, customeDateRange: penetrationCutomeDateRange)
        headerModel?.value = Double("")
        
        tableView.reloadData()
        EZLoadingActivity.hide()
    }
    
    func update(modeData:EarningsCellDataModel, withData data: [Dashboard.GetRevenueDashboard.Revenue_transaction]? = nil, atIndex index : Int, dateRange:DateRange, dateRangeType: DateRangeType) {
        
        var filteredPenetrationRatio = data
        
        //Date filter applied
        filteredPenetrationRatio = GlobalVariables.technicianDataJSON?.data?.revenue_transactions?.filter({ (penetration) -> Bool in
            if let date = penetration.date?.date()?.startOfDay {
                return date >= dateRange.start && date <= dateRange.end
            }
            return false
        })
        
        //invoice data
        let invoiceNumber = filteredPenetrationRatio?.filter({($0.invoice_number ?? "") != ""})
        let uniqueInvoices = invoiceNumber?.unique(map: {$0.invoice_number})
        
        
        var count : Int = Int(0.0)
        var invoceCount : Int = 0
        var ratio : Double = 0.0
        
        // for penetration in filteredPenetrationRatio ?? [] {
        let serviceCount = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
        switch index {
        case 0: // Service Count per Invoice
            
            //service count per invoice
            let serviceCount = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
            let invoiceService = filteredPenetrationRatio?.compactMap({$0.invoice_number}).unique(map: {$0})
            count = serviceCount!.count
            invoceCount = invoiceService!.count
            if(invoiceService!.count > 0){
                ratio =  Double(serviceCount!.count) / Double(invoiceService!.count)
            }
            /*
            //service count per invoice
            let serviceCount = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
            count = serviceCount?.count ?? 0
            
            let uniqueInvoice = serviceCount?.compactMap({$0.invoice_number}).unique(map: {$0})
            let countInvoice = uniqueInvoice?.count
            print("service \(count) invoice \(countInvoice)")
            if(countInvoice ?? 0 > 0){
                invoceCount = uniqueInvoices?.count ?? 0
                ratio = Double(count) / Double(countInvoice ?? 0)
            }
            */
        case 1:
            // Product To Service
            let productCount = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.retail)})
            count = productCount?.count ?? 0
            
           
            invoceCount = serviceCount?.count ?? 0
            
            if(invoceCount > 0){
                ratio = Double(count) / Double(invoceCount)
            }
            
        case 2:
//            let appBooking = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services) && (($0.platform ?? "").containsIgnoringCase(find:platform.CMA))})
//
//            //customers served - those are customer_id which are served
//            let filterCustomerServed = filteredPenetrationRatio?.filter({(($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)) && $0.customer_id != nil && $0.customer_id != 0}).unique(map: {$0.customer_id})
//
//            if(filterCustomerServed!.count > 0) {
//                ratio =  Double(appBooking?.count ?? 0) / Double(filterCustomerServed!.count)
//            }
//            //customers served
//            let filteredCustomerEngagement = GlobalVariables.technicianDataJSON?.data?.salon_feedbacks?.filter({ (customerEngagement) -> Bool in
//                if let date = customerEngagement.date?.date()?.startOfDay {
//
//                    return date >= dateRange.start && date <= dateRange.end
//                }
//                return false
//            })
//            let customersServed = filteredPenetrationRatio?.unique(map: {$0.customer_id})
          //  invoceCount = filterCustomerServed?.count ?? 0
//            for customers in customersServed ?? []{
//                invoceCount += customers.no_of_services ?? 0
//            }
            
        
            //app booking
            let appBooking = filteredPenetrationRatio?.filter({(($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)) && (($0.platform ?? "").containsIgnoringCase(find:platform.CMA))})
            
            var appBookingRatio : Double = 0.0
            
            //customers served - those are customer_id which are served
            let filterCustomerServed = filteredPenetrationRatio?.filter({(($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)) && $0.customer_id != nil && $0.customer_id != 0}).unique(map: {$0.customer_id})
            
            if(filterCustomerServed!.count > 0) {
                appBookingRatio =  Double(appBooking!.count) / Double(filterCustomerServed!.count)
            }
            count = appBooking!.count
            invoceCount = filterCustomerServed?.count ?? 0
            
        case 3:
            //cross sell
//            let crossSell = GlobalVariables.technicianDataJSON?.data?.cross_sell_transactions
            
            let filteredCrossSell = GlobalVariables.technicianDataJSON?.data?.cross_sell_transactions?.filter({ (crossSell) -> Bool in
                if let date = crossSell.date?.date()?.startOfDay {
                    
                    return date >= dateRange.start && date <= dateRange.end
                }
                return false
            })
            
            if let crossSellData = filteredCrossSell, crossSellData.count > 0{
                
                var crossSellRevenueCount : Double = 0.0
                for objCrossSell in crossSellData {
                    crossSellRevenueCount += objCrossSell.paid_service_revenue ?? 0.0
                }
                
                //"Cross Sell"
                //Data Model
                dataModel[index] = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Cross Sell", value: [String(crossSellData.count),crossSellRevenueCount.roundedStringValue()], subTitle: ["Services", "Revenue"], showGraph: true, cellType: .DoubleValue, isExpanded: false, dateRangeType: dateRangeType, customeDateRange: penetrationCutomeDateRange)
                
                
                
            }
            else {
                dataModel[index] = EarningsCellDataModel(earningsType: .PenetrationRatios, title: "Cross Sell", value: ["NA","NA"], subTitle: ["Services", "Revenue"], showGraph: true, cellType: .DoubleValue, isExpanded: false, dateRangeType: dateRangeType, customeDateRange: penetrationCutomeDateRange)
                
            }
            return
            
        default:
            //Penetration ratio dynamic data
            let penerationRatioFromFilters = GlobalVariables.technicianDataJSON?.data?.filters?.penetration_ratios ?? []
            //service count per invoice
            let serviceCount = filteredPenetrationRatio?.filter({($0.product_category_type ?? "").containsIgnoringCase(find:CategoryTypes.services)})
            var categotyCount : Int = 0
            var subCategoryCount : Int = 0
            var ratio : Int = 0
           
            var compareCategories = [String]()
            var toCompareCategories = [String]()
            var filterPenetrationArrayWithCategoryData = [Dashboard.GetRevenueDashboard.Revenue_transaction]()
            
            let category = penerationRatioFromFilters.filter({($0.heading?.containsIgnoringCase(find: dataModel[index].title))!})
            for objPenetration in category{
                if(objPenetration.heading == dataModel[index].title){
                    compareCategories.append(objPenetration.compare_label ?? "")
                    toCompareCategories.append(objPenetration.to_compare_label ?? "")
                }
                
                for objTransaction in filteredPenetrationRatio!  {
                    for objPenetration in penerationRatioFromFilters {
                        if((objTransaction.category == objPenetration.compare_label!) || (objTransaction.category == objPenetration.to_compare_label!)) {
                            categotyCount = categotyCount + 1
                            filterPenetrationArrayWithCategoryData.append(objTransaction)
                        }
                        
                        if((objTransaction.sub_category == objPenetration.compare_label) || (objTransaction.sub_category == objPenetration.to_compare_label)){
                            subCategoryCount = subCategoryCount + 1
                            filterPenetrationArrayWithCategoryData.append(objTransaction)
                        }
                    }
                }
            }
            categotyCount = (calculateCompareValue(revenueTransaction: filterPenetrationArrayWithCategoryData, comapreCategories: compareCategories, serviceCount: serviceCount?.count ?? 0))
                
            subCategoryCount = (calculateCompareValue(revenueTransaction: filterPenetrationArrayWithCategoryData, comapreCategories: toCompareCategories, serviceCount: serviceCount?.count ?? 0))
                
//            if(penerationRatioFromFilters.count > 0){
//                for objPenetration in penerationRatioFromFilters {
//
//                    for objTransaction in filteredPenetrationRatio! {
//
//                        let filter = objPenetration.compare_categories?.filter({($0 == objTransaction.category ?? "") || ($0 == objTransaction.sub_category ?? "")})
//                        categotyCount += filter?.count ?? 0
//
//                        if(objPenetration.to_compare_categories?.contains("All") == true){
//                            subCategoryCount = serviceCount!.count
//                        }
//                        else {
//                        let catfilter = objPenetration.to_compare_categories?.filter({($0 == objTransaction.sub_category ?? "") || ($0 == objTransaction.category ?? "")})
//                        subCategoryCount += catfilter?.count ?? 0
//                        }
//
//                    }
//                    if(subCategoryCount > 0){
//                        ratio = Int(Double(categotyCount) / Double(subCategoryCount))
//                    }
            
                    //"penetrationModel"
                    //Data Model
            dataModel[index] = EarningsCellDataModel(earningsType: .PenetrationRatios, title: dataModel[index].title, value: [categotyCount.roundedStringValue(toFractionDigits: 2),subCategoryCount.roundedStringValue(toFractionDigits: 2),ratio.roundedStringValue(toFractionDigits: 2)], subTitle: [dataModel[index].subTitle[0] ,dataModel[index].subTitle[1], "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: true, dateRangeType: dateRangeType, customeDateRange: penetrationCutomeDateRange)
                    
                    compareCategories.removeAll()
                    toCompareCategories.removeAll()
                    //                    dataModel.append(penetrationModel)
//                    //Graph Data
//                    graphData.append(getGraphEntry(penetrationModel.title, forData: filteredPenetrationForGraph, atIndex: index, dateRange: graphDateRange, dateRangeType: graphRangeType))
//                    print("INDEX \(index)")
//                    print("------------------ penetration ratio title \(penetrationModel.title)")
                    //                dataModel.append(EarningsCellDataModel(earningsType: .PenetrationRatios, title: objPenetration.heading ?? "", value: [String(subCategoryCount),String(categotyCount),String(ratio)], subTitle: [objPenetration.compare_label ?? "" ,objPenetration.to_compare_label ?? "", "Ratio"], showGraph: true, cellType: .TripleValue, isExpanded: false, dateRangeType: dateRangeType, customeDateRange: penetrationCutomeDateRange))
//                }
//
//            }
            return
            
        }
        // }
        
        dataModel[index] = EarningsCellDataModel(earningsType: modeData.earningsType, title: modeData.title, value: [String(count),String(invoceCount),ratio.roundedStringValue(toFractionDigits: 2)], subTitle: [modeData.subTitle[0], modeData.subTitle[1], modeData.subTitle[2]], showGraph: modeData.showGraph, cellType: modeData.cellType, isExpanded: modeData.isExpanded, dateRangeType: modeData.dateRangeType, customeDateRange: modeData.customeDateRange)
        
        EZLoadingActivity.hide()
        
    }
    
}

extension PenetrationRatiosViewController: EarningsFilterDelegate {
    
    func actionDateFilter() {
        let vc = DateFilterVC.instantiate(fromAppStoryboard: .Earnings)
        self.view.alpha = screenPopUpAlpha
        vc.fromChartFilter = false
        vc.selectedRangeTypeString = dateRangeType.rawValue
        vc.cutomRange = penetrationCutomeDateRange
        UIApplication.shared.keyWindow?.rootViewController?.present(vc, animated: false, completion: nil)
        vc.viewDismissBlock = { [unowned self] (result, startDate, endDate, rangeTypeString) in
            // Do something
            self.view.alpha = 1.0
            if(result){
                fromChartFilter = false
                self.view.alpha = 1.0
                if(result){
                    dateRangeType = DateRangeType(rawValue: rangeTypeString ?? "") ?? .cutome
                    bottomFilterView.updateText(dateRangeType)
                    if(dateRangeType == .cutome), let start = startDate, let end = endDate
                    {
                        penetrationCutomeDateRange = DateRange(start,end)
                    }
                    updatePenetrationData(startDate: startDate ?? Date.today, endDate: endDate ?? Date.today)
                    
                    tableView.reloadData()
                }
            }
        }
    }
    
    func actionNormalFilter() {
        print("Normal Filter")
    }
}

extension PenetrationRatiosViewController: EarningDetailsDelegate {
    
    func reloadData() {
        self.tableView.reloadData()
    }
    
    func actionDurationFilter(forCell cell: UITableViewCell) {
        guard let indexPath = tableView.indexPath(for: cell), dataModel.count >= indexPath.row else { return }
        
        let selectedIndex = indexPath.row - 1
        
        let vc = DateFilterVC.instantiate(fromAppStoryboard: .Earnings)
        vc.isFromProductivity = false
        self.view.alpha = screenPopUpAlpha
        vc.fromChartFilter = true
        if(selectedIndex >= 0){
            let model = dataModel[selectedIndex]
            vc.selectedRangeTypeString = model.dateRangeType.rawValue
            vc.cutomRange = model.customeDateRange
        }
        else if let model = headerModel {
            vc.selectedRangeTypeString = model.dateRangeType.rawValue
            vc.cutomRange = model.customeDateRange
        }
        UIApplication.shared.keyWindow?.rootViewController?.present(vc, animated: false, completion: nil)
        vc.viewDismissBlock = { [unowned self] (result, startDate, endDate, rangeTypeString) in
            // Do something
            self.view.alpha = 1.0
            if result == true, startDate != nil, endDate != nil {
                fromFilters = false
                fromChartFilter = true
                
                let rangeType  = DateRangeType(rawValue: rangeTypeString ?? "") ?? .cutome
                updatePenetrationData(atIndex: indexPath, withStartDate: startDate, endDate: endDate!, rangeType: rangeType)
                
                tableView.reloadRows(at: [indexPath], with: .automatic)
                let text = "You have selected \(rangeTypeString ?? "MTD") filter from Charts."
                self.showToast(alertTitle: alertTitle, message: text, seconds: toastMessageDuration)
            }
        }
    }
}


extension PenetrationRatiosViewController: UITableViewDelegate, UITableViewDataSource {
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return dataModel.count + 1
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        if indexPath.row == 0 {
            guard let cell = tableView.dequeueReusableCell(withIdentifier: CellIdentifier.earningDetailsHeaderCell, for: indexPath) as? EarningDetailsHeaderCell else {
                return UITableViewCell()
            }
            if let model = headerModel {
                var data:[GraphDataEntry] = []
                if let hgraphData = headerGraphData {
                    data = [hgraphData]
                }
                cell.configureCell(model: model, data: data)
            }
            cell.delegate = self
            cell.parentVC = self
            cell.selectionStyle = .none
            return cell
        }
        else {
            guard let cell = tableView.dequeueReusableCell(withIdentifier: CellIdentifier.earningDetailsThreeValueCell, for: indexPath) as? EarningDetailsThreeValueCell else {
                return UITableViewCell()
            }
            cell.selectionStyle = .none
            cell.delegate = self
            cell.parentVC = self
            
            let index = indexPath.row - 1
            let model = dataModel[index]
            let barGraph = graphData[index]
            
            cell.configureCell(model: model, data: [barGraph])
            return cell
        }
        
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return UITableView.automaticDimension
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print("Selection")
    }
    
//    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
//        guard let cell = tableView.dequeueReusableCell(withIdentifier: CellIdentifier.earningDetailsHeaderFilterCell) as? EarningDetailsHeaderFilterCell else {
//            return UITableViewCell()
//        }
//        cell.delegate = self
//        cell.configureCell(showDateFilter: true, showNormalFilter: false, titleForDateSelection: dateRangeType.rawValue)
//        cell.selectionStyle = .none
//        return cell
//    }
//
//    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
//        return 60
//    }
}
